// Cosmic Praise Muon Detector - Signal Amplifier - A/D Interface
// Author: Joshua Krueger
// Version: 2
// Created August 13, 2014, 1:29 PM

// Two analog signal channels (RA0/AN0, RA1/AN1) represent inputs PMT1, PMT2
// from the coincidence detector.  These levels are converted and encoded for 
// serial transmission for use by the LED pattern generator.  Digital signal 
// RB0 indicates a coincidence event and triggers the serial transmission of a 
// set of PMT samples.

// Processor configuration
// Target processor: PIC16F1518, 28 pin 8 bit, 16 MHz
// 16k program memory, 1k SRAM.
#define _XTAL_FREQ 16000000

#include <xc.h>
// Configuration generated by mplabx Window->Pic Memory Views->Configuration Bits dialog.
// CONFIG1
#pragma config FOSC = INTOSC    // Oscillator Selection (INTOSC oscillator: I/O function on CLKIN pin)
#pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
#pragma config PWRTE = ON       // Power-up Timer Enable (PWRT enabled)
#pragma config MCLRE = ON       // MCLR Pin Function Select (MCLR/VPP pin function is MCLR)
#pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
#pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
#pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
#pragma config IESO = ON        // Internal/External Switchover (Internal/External Switchover mode is enabled)
#pragma config FCMEN = ON       // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is enabled)

// CONFIG2
#pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
#pragma config VCAPEN = OFF     // Voltage Regulator Capacitor Enable bit (VCAP pin function disabled)
#pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
#pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
#pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
#pragma config LVP = ON         // Low-Voltage Programming Enable (Low-voltage programming enabled)


// Theory of Operation
//
// A/D conversion consists of two time intensive phases.
//
// The first, after channel selection is called the acquisition time.  This is
// the time required for the PIC's charge holding capacitor (CHOLD) to charge
// to the input channel voltage level.  This minimum time must be met after a
// channel is selected and before the conversion step to ensure full 10 bit
// resolution.  The data sheet is somewhat ambiguous about a number of the
// pieces of information required to calculate this value, but becuase we have
// good opamp output drive, I'm gonna (until proven otherwise) assume approx
// the value given in the datasheet example, which is likely typical.  See
// DS40001452D, pg 145 (also DS40001452D-page 299).  Therefore, Tacq, for our
// purposes is 5us.
//
// The second phase is conversion.  This step is governed by the ADC conversion
// clock selection, which is chosen based on the PIC oscillator speed, and
// defines the time taken to convert 1 bit (Tad).  Minimum recommended Tad is
// 1us.  A full conversion takes 11.5 Tad.  After the conversion is started by
// setting the GO bit, completion of the full conversion time is indicated
// either by polling this same bit, or responding to an interrupt generated by
// the same event.
//
// Most of the rest of A/D conversion processing takes no time, so approx sample
// rate is 16.5 uS, which is ~60kHz, or 30kHz per channel due to alternation.
//
// For the first phase, we must find some way of waiting (timer or delay), and
// for the second phase, either poll for completion or respond to the generated
// interrupt.
//
// POR - Set a timer for the first wait, poll for the second
// phase.
//
// In addition to A/D sampling and conversion, the device will monitor the Gate
// Sense input on RB0 for pulses indicating that an event has occured.  An event
// interrupt will trigger the sending of a data packet over the serial port that
// will include several (3 before, 3 after) of the adjacent PMT samples.  This
// tranmission may take anywhere from 1-20 ms depending ultimately on the
// transmission speed and size of the packet (currently 2.1ms).  We could
// continue sampling during this time, but this would
// require interrupt driven serial code, which is somewhat more complex, and I'm
// gonna say pointless because we are dealing with times below human perception
// thresholds anyway.  Disabling the gate sense interrupt during the
// transmission period may have the added benefit of providing a certain amount
// of debouncing to the input.

// Project defines
#define FOREVER for(;;)

// ADC Channels
#define CHANNEL_COUNT 2
#define CH_PMT1 0b00000
#define CH_PMT2 0b00001
#define SAMPLE_COUNT 6
#define MSB 1
#define LSB 0
const char channelMap[CHANNEL_COUNT] = {CH_PMT1, CH_PMT2};
#define BYTES_PER_SAMPLE 2

// Globals
volatile unsigned char eventOccurred = 0;

// Prototypes
void InitHardware(void);

// Main function
void main(void) {

  // Vars
  char channel = 0;
  char sample = 0;
  unsigned char samples[CHANNEL_COUNT][SAMPLE_COUNT][BYTES_PER_SAMPLE];
  unsigned char sendASet = 0;
  unsigned char eventInProgress = 0;
  char countDown = 0;
  char i,j,k;

  InitHardware();

  // Init samples to 0.
  for (i = 0; i < CHANNEL_COUNT; i++) {
    for (j = 0; j < SAMPLE_COUNT; j++) {
      for (k = 0; k < BYTES_PER_SAMPLE; k++) {
        samples[i][j][k] = 0;
      }
    }
  }



  FOREVER {
    // A/D Conversion - We spend most of our time here because events are few
    // and far between.

    // 1) Set up the channel for acquisition.
    ADCON0bits.CHS = channelMap[channel];

    // 2) Wait the required acquisition time.  We'll use Timer0 for this.  I
    // was gonna use NOPs (20 of them), but interrupts during this time would
    // alter the sample rate, which I want to minimize.
    // 0xFF-0xEF = 16 + 1 (Overflow @ FF->00) + 2 (TMR0 assignment inhibits
    // timer0 for 2 cycles), +1 (instructions passed since channel change).
    // ~20 x 250ns = 5us.  This should be enough.  Look at the disassembly.
    // In fact, maybe 0xF0 instead of 0xEF, but whatevs.
    TMR0 = 0xEF;  // 3 instructions.
    INTCONbits.TMR0IF = 0; // Make sure the timer0 flag is clear.  1 instruction.
    // We might use the interrupt, but since we aren't doing anything, we'll
    // just poll for the flag to change.
    while (!INTCONbits.TMR0IF) {} // Two instructions.
    
    // 2) Start the conversion by setting the GO bit.
    ADCON0bits.GO = 1;

    // 3) Wait for ADC conversion to complete by polling the GO/DONE bit.
    while (ADCON0bits.GO) {} // Insert T/O here? - I didn't use WDT...

    // 4) Place the ADC result into the circular buffer.
    samples[channel][sample][MSB] = ADRESH;
    samples[channel][sample][LSB] = ADRESL;

    // 5) Set up for the next acquisition
    channel++;
    if (channel >= CHANNEL_COUNT) {
      channel = 0;
      sample++;
      if (sample >= SAMPLE_COUNT) {
        sample = 0;
      }
    }

    // Check our event status.
    if (eventOccurred) {
      if (!eventInProgress) {
        // An event has occured, but nothing has been done about it yet, and
        // there are no other events in progress.  We'll set up the sample
        // countdown clock.
        eventInProgress = 1;
        countDown = (SAMPLE_COUNT * CHANNEL_COUNT) / 2;  // 6 samples after, 6 before.
        if (channel == (CHANNEL_COUNT - 1)) {
          // We're halfway through a sample set so we'll finish this one to
          // make sure we send at least three whole sets after the event.
          countDown = ((SAMPLE_COUNT * CHANNEL_COUNT) / 2) + 1;
        }

        // If
      } else {
        // We are handling an event.  We must complete our sample set before
        // sending it out.
        countDown--;
        if (countDown == 0) {
          sendASet = 1;
        }
      }

      // All samples collected.  Do the serial transmission.  Sampling
      // activities are suspended until this is complete.
      if (sendASet) {
        // Format: 24 bytes. @~115.2kbps, 1 bit = 8.75us. 1 byte = 10 bits.
        // 1 byte = 87.5us. 24 bytes = 2100us, ~2.1ms transmission time.
        // Bytes sent:  PMT1-MSB-3, PMT2-MSB-3, PMT1-MSB-2, PMT2-MSB-2,
        // PMT1-MSB-1, PMT2-MSB-1, PMT1-MSB+1, PMT2-MSB+1, PMT1-MSB+2,
        // PMT2-MSB+2, PMT1-MSB+3, PMT2-MSB+3, PMT1-LSB-3, PMT2-LSB-3,
        // PMT1-LSB-2, PMT2-LSB-2, PMT1-LSB-1, PMT2-LSB-1, PMT1-LSB+1,
        // PMT2-LSB+1, PMT1-LSB+2, PMT2-LSB+2, PMT1-LSB+3, PMT2-LSB+3
        // LSB values are upper 2 bits of the byte.  The lower 6 bits are
        // always 0.  The event will have been received in either 1 of 2 places:
        // Between sample PMT2-1 and PMT1+1, or between PMT1-1 and PMT2-1.

        // Figure out where to start.  By this point, channel should be 0 and
        // sample should point to the sample number after the last sample
        // taken, which is 3 samples after the event occurred, and happens to
        // correspond, in our circular buffer to three samples prior to the
        // event.
        for (i = 0; i < SAMPLE_COUNT; i++) {
          for (j = 0; j < CHANNEL_COUNT; j++) {
            for (k = 0; k < BYTES_PER_SAMPLE; k++) {
              while(!PIR1bits.TXIF) {} // Make sure the serial port is clear.
              TXREG = samples[sample][j][k];
              asm("nop");  // Makes sure TXIF isn't immediately tested after TXREG.
              asm("nop");
            }
          }
          sample++;
          if (sample >= SAMPLE_COUNT) {
            sample = 0;
          }
        }

        // Reset all the flags so we can start sampling again.
        sendASet = 0;
        eventInProgress = 0;
        eventOccurred = 0;
        sample = 0;

        // We'll go ahead and zero out the sample set here so that old data
        // won't leak into subsequent consequetive events.
        for (int i = 0; i < SAMPLE_COUNT; i++) {
          for (int j = 0; j < CHANNEL_COUNT; j++) {
            for (int k = 0; k < BYTES_PER_SAMPLE; k++) { // LSB, MSB
              samples[i][j][k] = 0;
            }
          }
        }
      }
    }
  }
}

void InitHardware(void) {
  // Port usage
  // Port A
  // RA0/AN0 - PMT1 analog input
  // RA1/AN1 - PMT2 analog input
  // RA5/AN4 - Unknown Digitial output - Control switch for U12? - Tristate / Digital input for now.
  // RA2, RA3, RA4, RA6, RA7 - NC - (Digital Inputs)
  TRISA = 0b11111111;
  ANSELA = 0b00000011;  // RA0, RA1 set to analog input.  All others digital.
  LATA = 0;

  // Port B
  // RB0, RB1, RB2, RB3, RB4, RB5 - NC - (Digital Inputs)
  // RB6, RB7 - NC / Programming port - (Digital Inputs)
  TRISB = 0b11111111;
  ANSELB = 0; // All digital ports.
  LATB = 0;

  // Port C
  // RC0, RC1, RC3, RC4, RC5, RC7 - NC - (Digital Inputs)
  // RC2 - Gate sense - Digital input
  // RC5 - UART Tx peripharal output - set as input, let the periph init open it.
  TRISC = 0b11111111;  // If this doesn't work, try 0b11011111
  ANSELC = 0; // All digital ports.
  LATC = 0;

  // Oscillator selection
  // OSCCON
  OSCCONbits.SCS = 0b11;  // Clock set to internal oscillator.
  OSCCONbits.IRCF = 0b1111; // 16MHz clock selected.

  // ADC Inits - Port configuration already complete (TRIS, ANSEL).
  // ADC clock period from Table 16-1, DS40001452D pg 137.
  // FOSC = 16MHz.  Tad chosen 1us (FOSC / 16), fastest without violation of minimum timing req.
  // ADCON0,1 - Analog control register.
  ADCON0bits.GO = 0; // Don't GO yet.
  ADCON1bits.ADFM = 0; // Left justified result.  ADRESH is 8 MSB, ADRESL is 2 LSB, 6 zeroes.
  ADCON1bits.ADCS = 0b101; // Conversion clock, Taq = FOSC/16.
  ADCON1bits.ADPREF = 0;   // VREF connected to VDD.
  ADCON0bits.CHS = CH_PMT1;  // Initial analog channel assignment.
  ADCON0bits.ADON = 1; // Enable ADC.
  
  // EUSART Inits
  // Baud rate from table 22-5, DS40001452D-page 248.
  // Selected baud = 115.2k (114.29k @ -0.79% error)
  BAUDCONbits.BRG16 = 1; // 16 bit baud rate generator.
  TXSTAbits.BRGH = 1; // Baud rate generator select, 1 = high speed.
  SPBRGH = 0;
  SPBRGL = 0x22; // 34 decimal.
  TXSTAbits.TXEN = 1; // Enable transmit (sets TXIF).
  TXSTAbits.SYNC = 0; // Asynchronous mode.
  TXSTAbits.TX9 = 0; // 8 bit transmission.
  RCSTAbits.SPEN = 1; // Serial port enable - configures the pins to be TX / RX.

  // Timer0 setup - used for the acquisition time.
  OPTION_REGbits.PSA = 1;  // Disables prescaler for timer0.  This makes PS bits don't care.
  OPTION_REGbits.TMR0CS = 0; // Timer 0 clock is FOSC / 4.

  // INT Interrupt on RB0:
  OPTION_REGbits.INTEDG = 1; // Rising edge.
  INTCONbits.INTE = 1; // Enable INT interrupt.
  INTCONbits.GIE = 1; // Enable interrupts.
}


// Handle the various interrupts.
void __interrupt InterruptVector(void) {
  // The only thing we have to do here is respond to the Interrupt On Change
  // that indicates an event.
  if (INTCONbits.INTF) {
    eventOccurred = 1;
    INTCONbits.INTF = 0;
  }
  // It is not necessary to set GIE as RETFIE supposedly does this.
}
